
----------------------- REVIEW 1 ---------------------
Overall evaluation: 0 (borderline paper)
----------- Overall evaluation -----------

The authors claim that these extensions are useful for runtime verification and present some minimal experimental results from running a BDD-based implementation of the extensions.

=== our rebuttal response: ===
We have presented many experiments in previous papers, which are
publicly available with our tool. We added here experiments to show
the strength of the extension.
==============================

I am not quite on board with the motivation of the paper. In runtime verification, the truth values of formulas are determined on a single trace, hence, in particular, LTL and CTL are equivalent, and the verification is hence polynomial. It is also quite standard in model-checking to augment the intermediate states on the path with the truth values of subformulas (this is how CTL model checking is done, and hence also LTL for a single trace). Wouldn't it address at least some of the concerns of the authors (that is, which subformulas are satisfied in which states)?

=== our rebuttal response: ===
For unbounded data and unbounded sequences, the size of information
that needs to be stored can grow unboundedly. Our BDD representation,
however, shows impressive results, handlingvery  large traces.
==============================

Also, I see no reference to PSL, which is the IEEE standard for property specification languages, or to ForSpec, which is Intel's specification language. I am wondering whether these would already provide the necessary functionality.

=== our rebuttal response: ===
We will cite this work. However, PSL is limited in the way it handles
data, and is basically a strong propositional logic. It is equivalent
to some propositional logics we cite.  We introduced the propositional
extension with rules to demonstrate how elegant (not more expressive!)
our extension is,  that a simple extension to a classical RV algorithm
handles it, and to motivate the related extension to first-order LTL.
==============================

Adding quantification is solvable, in general, with a QBF solver, and in some cases even without it. In the Intel's paper about enhanced vacuity from the beginning of 2000's, they studied the problem of model-checking a quantified formula and demonstrated that for the types of formulas they constructed it is no harder than model-checking.

=== our rebuttal response: ===
There are two types of quantifiers: propositional quantifiers, as
QLTL, as dealt with in the paper you mention, and first-order
quantification (in our logics named with letter 'F'). Our contribution
is w.r.t. handling the first-order version, so the work mentioned is
not connected.
==============================

Finally, I might be wrong, but it seems to me that BDDs are no longer widely used in model-checking, replaced by SAT and SMT solvers. I am wondering whether the implementation with BDDs is interesting enough.

=== our rebuttal response: ===
The main problem studied in handling RV for first-order LTL with data
is the representation of relations over data, which are accumulated
throughout the execution. In our BDD encoding of relations, we can use
efficient Boolean BDD operators to implement intersection, union and
complementation of relations. This is surprisingly efficient allowing
handling of very large traces with lots of data.
==============================

----------------------- REVIEW 2 ---------------------
Overall evaluation: -1 (weak reject)
----------- Overall evaluation -----------

While the paper explores a potentially useful abstraction for runtime
verification, it was hard to fully understand the motivation for this
work. Some ways that the work could be strengthened are listed below.

=== our rebuttal response: ===

==============================

Thm. 1 and Lemma 2 show that the introduced logics (ELTL and EPLTL)
have the same expressive power as Q(P)LTL. The authors should make
the benefit of introducing these new logics more clear. Thm. 2 shows
that QPFLTL is more expressive than EPFLTL, but the authors do not
provide any complexity results on the decidability of these logics -
for what benefit are we trading the expressivity? Thm 2 also opens
the question of whether EQPFLTL makes sense and if so how it relates
to the other permutations of (E/Q/F/PLTL).

=== our rebuttal response: ===
The main reason for moving from 'Q' to 'E', e.g. from QPFLTL to
EPFLTL, is that we can show how to construct an efficient monitoring
algorithm for 'E' (e.g. EPFLTL), whereas we do not see how to do this
for 'Q' (e.g. QPFLTL). We do not believe there is a reasonable
algorithm for the 'Q' version and the example in the proof gives some
insight of what is involved.
==============================

The limitations of existing runtime verification systems for data 
intensive systems could be made more clear through an evaluation 
that compares the use of EFPLTL for runtime verification with the 
alternative existing approaches. At the moment the evaluation only 
presents benchmarks for the introduced tool, but does not situate 
this evaluation in the context of existing runtime verification tools.

=== our rebuttal response: ===
In [23] we compared with MonPoly, which is closest, since it includes
FPLTL.
==============================

Furthermore, the evaluation includes a 'spawning' trace where analysis
time appears to scale exponentially in the size of the trace. The
authors mention this is possibly due to the increasingly large amount
of data that must be stored as the trace grows. As the system is
intended to be used for runtime verification, what practical
consideration must be made given the exponentially scaling with
respect to the lifecycle of the task being monitored?

=== our rebuttal response: ===
The BDD representation of relations showed on many examples (open
source) to be quite compact. The original version of the tool also
performs a clever form of garbage collection, described in [24].
Indeed, BDDs are not a magic fix-all tool, but we obtain impressive
results.
==============================

In addition, a more thorough analysis of memory usage should be
included in the evaluation. No information is provided on the system
that ran these evaluation results. Do these benchmarks' memory usage
exceed the available RAM and trigger disk operations? As the temporal
relations of (P)FLTL require increasingly large hash tables to save
their evaluations, what impact will this have on memory limited
systems? This is especially relevant for the many use cases of
runtime verification on embedded systems.

=== our rebuttal response: ===
Memory analysis is missing, agreed.
==============================

[KH: use UNIX tool psrecord for memory analysis]

Another issue is that it was hard to identify the paper's
contribution. The section on 'Runtime verification algorithm for
PFLTL' has already been described in [24]. To handle EPFLTL, Sec 5
introduces a single 'rename' function which seems a relatively small
delta with respect to [24]. The authors point us back to section 3
(mixed evaluation order) for further contributions with respect to
[24] to handle EPFLTL, but it is then not clear why Section 3 is
separate from Section 5.

=== our rebuttal response: ===

==============================

The paper should better position its contributions wrt. related work.
Throughout the paper, the authors should make it more obvious to the
reader that only logics prefixed with an E are new logics introduced
in this work (if I understood the paper correctly). However, the
authors present a much clearer and unified semantics for E/Q/P/FLTL
than can be found in prior work - this is a valuable contribution in
and of itself. Highlighting this may strengthen the motivation for
the extensive re-presentation of existing work.

=== our rebuttal response: ===
Yes, although see also introduction to this response above.
==============================

Additionally, the use of predicates to encode information about the
prefix of the state (system inputs seen so far), and thereby allowing
arbitrary data over infinite domains, was explored in 'Synthesizing
Functional Reactive Programs' by Finkbeiner et. al
https://arxiv.org/abs/1712.00246.

=== our rebuttal response: ===
We were not aware of this paper (it appears as an archived paper).  It
seems that the TSL assignments only assign one value to a
variable. We do not claim to have introduced predicates to
encode information about the prefix of the execution, we refer to paper [4].
Our approach introduces and adds to the LTL syntax predicates 
that are defined in the current state based on parametrized past FO-LTL.
==============================

- As an example, the top of page 5 notes that the logic PQLTL is
  obtained by restricting QPLTL to past modalities. From context, it
  appears this should read as QLTL, not QPLTL. 

[KH: DONE.]

- Furthermore, by page 6 the authors are proving properties of QPLTL, but PQLTL is no longer
  referenced. Although from context the reader can infer that QPLTL and
  PQLTL these should be taken as the same logic (except on page 5 when
  QPLTL refers to QLTL), these inferences should not be left to the
  reader. 

[KH: DONE. Changed all occurrences of PQLTL to QPLTL. This way both E and Q are always at the
outermost level.]

- I also believe that there is an issue with Theorem 2 - when
  comparing the expressive power of EPFLTL and QFPLTL, the statement
  instead reads as comparing EPFLTL and QFLTL.

[KH: DONE, changed QFLTL to QPFLTL, But Doron check that this is indeed as it should be]

----------------------- REVIEW 3 ---------------------
PAPER: 139
Overall evaluation: 2 (accept)
----------- Overall evaluation -----------

The formalism is at times a bit sketchy, but the overall ideas are clearly explained.  

=== our rebuttal response: ===

==============================

The experimental results seem preliminary: apart from the fact that the examples are made up, it's unclear how the collection of traces was generated.   

=== our rebuttal response: ===
The artificial traces were generated by a trace generating program
parameterized with various constants, indicating how many events of
various kinds should be generated, and the patterns with which they
are generated. The objective was to generate as many data values in
the trace as possible, while at the same time also cause repetition of
patterns.
==============================

It would be more convincing to see this applied to more realistic examples (esp the transitive closure property surely has many applications).

=== our rebuttal response: ===
Agreed! 
==============================

Comments:

* p.1, fifth line from bottom: "By Wolper" ==> "by Wolper"

[KH: DONE.]

* p.2, second para, "unexpressiveness" ==> "inexpressiveness"

[KH: DONE.]

* p.3, the Related Work section is quite terse.  In particular, it lists a set of papers, but does not really "relate" the current work.  (Actually, the introduction on p.2 does a better job of this.)

* p.5, formulae (1) and (2) could be made to look more similar.  In (2), you distribute H() over the /\.  Could do the same in (1) with \Box

* p.5, middle of page.  Your restriction on the rules is that
   "\phi_i is a PLTLT property where propositions from B can only occur within the scope of (-)"
  But at the bottom of the page you say
   "auxiliary variables appearing in the formulas \phi_i must occur within the scope of a (-)"
  These seem inconsistent (since the auxiliary variables are in A, not in B).

[KH: DONE, changed B to A].

* p.6, Lemma 1, "Let \sigma be a model with states over the B".  Get rid of "the"

[KH: DONE.]

* p.8, 2nd para, "where one distinguished state, s, in a sink state".  Change "in" to "is"

[KH: DONE]

* p.11, item 3 under "Extending FLTL with rules".  "An auxiliary relations r_j can appear"
    Change "relations" to "relation"

[KH: DONE]

* p.12, second para, "The reason is that every prefix of an model".  Change "an" to "a"

[KH: DONE]

* p.15, second para, "The properties are The ASCII version of the logic" ?? Fix.

[KH: DONE]

* p.15, third para, "The third alternative here states that we in the previous state were in"
   Should be "The third alternative here states that in the previous state we were in"

[KH: DONE]

----------------------- REVIEW 4 ---------------------
PAPER: 139
Overall evaluation: 0 (borderline paper)
----------- Overall evaluation -----------

Adding auxiliary state machines to temporal specifications is, of
course, not new. It was used, for example, in early model checking
tools like SMV and RuleBase. There are some nice aspects to the
particular approach proposed here, however. First, the auxiliary state
is expressed in terms of relations. This gives a succinct and abstract
way of expressing, for example, the state of protocols, and is similar
to the way the state is expressed in Gurevich's Evolving Algebras
(later Abstract State Machines) which were used in the 90's as a test
oracle for monitoring protocols (and later Ivy also used a similar
approach).  As an example in the paper shows, this gives a simple way
to construct the transitive closure of of a graph as it is built, even
though transitive closure is not expressible in the logic.  The
paper's approach goes a little further that this, however, since it
also allows the use of past-time temporal operators in the description
of the state machines. This doesn't add expressiveness for safety
properties, but it might improve succinctness or clarity of
specifications. It would be nice, in fact, if the paper showed an
example of this capability.

Adding the auxiliary state machines is a fairly straightforward
extension to the tool's existing monitoring algorithm based on BDD's.

Where the paper is somewhat lacking is in the evaluation. That is, a
few examples are given of specifications using auxiliary relations,
but these are toys and don't really indicate how well the method will
scale. The free use of quantifiers in the formulas, while it allows
succinct expression, might also harm scalability. As an example, to
avoid the costly use of quantifiers, it is typical and very helpful to
use maps (i.e., functions) in the auxiliary state. A map can be
modeled by a relation but at the cost of existential quantifier when
the map is applied. Because of such trade-offs, it would be very
useful to have a substantial protocol expressed in the logic, and to
see how well the monitoring algorithm scales, compared, for example,
to the Abstract State Machines approach. The transitive closure
example hints at what is possible in the formalism, but it doesn't
tell us if the approach makes a good (or transparent) trade-off
between ease of expression and cost.

The paper's formalism gives an elegant way of capturing the common
notion of auxiliary variables. However, it doesn't go deeply enough into the questions of succinctness and tractability that are crucial to any specification formalism, and as a result it doesn't really motivate the approach. There is a fair amount of material in the paper that is familiar or is background from prior work. Perhaps this could be reduced in order to make space for discussion of these issues.


-------------------------  METAREVIEW  ------------------------

Although the reviewers found the paper's formalism to be elegant and clearly explained, there were concerns in the areas of: 

- motivation.
- technical depth.
- practical evaluation, more substantial examples in the evaluation.
- comparison to the wide range of existing specification techniques.
- the question of memory behavior over long traces.  
- a deeper analysis of how the logic's design choices affect succinctness, readability and 
  tractability would be helpful.
