Dear Klaus,

Thank you for your submission to CAV 2019. The CAV 2019 review
response period starts now and will end March 27 at midnight 
(Anywhere on Earth).

During this time, you will have access to the current state of
your reviews and have the opportunity to submit a response of
up to 800 words. Please keep in mind the following during this
process:

* The response must focus on any factual errors in the reviews
and any questions posed by the reviewers. It must not provide
new research results or reformulate the presentation. Try to be
as concise and to the point as possible.

* Since we are following the full double blind policy for regular
papers, please ensure that your responses preserve anonymity. 
However, this requirement does not apply to tool or case study
papers.

* The review response period is an opportunity to react to the
reviews, but not a requirement to do so. Thus, if you feel the
reviews are accurate and the reviewers have not asked any
questions, then you do not have to respond.

* The reviews are as submitted by the PC members, without any
coordination between them. Thus, there may be inconsistencies.
Furthermore, these are not the final versions of the reviews.
The reviews can later be updated to take into account the
discussions at the program committee meeting, and we may find
it necessary to solicit other outside reviews after the review
response period.

* The program committee will read your responses carefully and
take this information into account during the discussions. On
the other hand, the program committee is not required to directly 
respond to your responses.

* Your response will be seen by all PC members who have access
to the discussion of your paper, so please try to be polite and
constructive.

The reviews on your paper are attached to this letter. To
submit your response you should log on the EasyChair Web page
for CAV 2019 and select your submission on the menu.

----------------------- REVIEW 1 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: 0 (borderline paper)

----------- Overall evaluation -----------
The paper describes several extensions to the temporal logic LTL, motivated by runtime verification application. The extensions are as follows:
- dynamic quantification - an LTL formula is augmented with \exists q, where q stands for an auxiliary variable that labels the states on the trace under verification;
- extension with rules - an LTL formula is augmented with a rule "where <some formula on auxiliary variables>"
- first-order LTL with dynamic quantification and with rules (separately).

The authors claim that these extensions are useful for runtime verification and present some minimal experimental results from running a BDD-based implementation of the extensions.

I am not quite on board with the motivation of the paper. In runtime verification, the truth values of formulas are determined on a single trace, hence, in particular, LTL and CTL are equivalent, and the verification is hence polynomial. It is also quite standard in model-checking to augment the intermediate states on the path with the truth values of subformulas (this is how CTL model checking is done, and hence also LTL for a single trace). Wouldn't it address at least some of the concerns of the authors (that is, which subformulas are satisfied in which states)?

Also, I see no reference to PSL, which is the IEEE standard for property specification languages, or to ForSpec, which is Intel's specification language. I am wondering whether these would already provide the necessary functionality.

Adding quantification is solvable, in general, with a QBF solver, and in some cases even without it. In the Intel's paper about enhanced vacuity from the beginning of 2000's, they studied the problem of model-checking a quantified formula and demonstrated that for the types of formulas they constructed it is no harder than model-checking.

Finally, I might be wrong, but it seems to me that BDDs are no longer widely used in model-checking, replaced by SAT and SMT solvers. I am wondering whether the implementation with BDDs is interesting enough.

----------------------- REVIEW 2 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: -1 (weak reject)

----------- Overall evaluation -----------
# Summary

In this paper the authors introduce an extension to LTL (which the
authors call ELTL) that allows reasoning about unbounded datatypes by
way of auxillary relations. These auxillary relations' values at a given
time stamp are defined by the prefix of the current state of the
reactive system. This allows the logic to specify properties of data
values over infinite domains. The authors implemented a system for
the runtime verification of properties expressed in this new logic. A
evaluation is provided that demonstrates how the tools performs on
benchmarks of various sizes.

# Review

While the paper explores a potentially useful abstraction for runtime
verification, it was hard to fully understand the motivation for this
work. Some ways that the work could be strengthened are listed below.

Thm. 1 and Lemma 2 show that the introduced logics (ELTL and EPLTL)
have the same expressive power as Q(P)LTL. The authors should make
the benefit of introducing these new logics more clear. Thm. 2 shows
that QPFLTL is more expressive than EPFLTL, but the authors do not
provide any complexity results on the decidability of these logics -
for what benefit are we trading the expressivity? Thm 2 also opens
the question of whether EQPFLTL makes sense and if so how it relates
to the other permutations of (E/Q/F/PLTL).

The limitations of existing runtime verification systems for data 
intensive systems could be made more clear through an evaluation 
that compares the use of EFPLTL for runtime verification with the 
alternative existing approaches. At the moment the evaluation only 
presents benchmarks for the introduced tool, but does not situate 
this evaluation in the context of existing runtime verification tools.

Furthermore, the evaluation includes a 'spawning' trace where analysis
time appears to scale exponentially in the size of the trace. The
authors mention this is possibly due to the increasingly large amount
of data that must be stored as the trace grows. As the system is
intended to be used for runtime verification, what practical
consideration must be made given the exponentially scaling with
respect to the lifecycle of the task being monitored?

In addition, a more thorough analysis of memory usage should be
included in the evaluation. No information is provided on the system
that ran these evaluation results. Do these benchmarks' memory usage
exceed the available RAM and trigger disk operations? As the temporal
relations of (P)FLTL require increasingly large hash tables to save
their evaluations, what impact will this have on memory limited
systems? This is especially relevant for the many use cases of
runtime verification on embedded systems.


Another issue is that it was hard to identify the paper's
contribution. The section on 'Runtime verification algorithm for
PFLTL' has already been described in [24]. To handle EPFLTL, Sec 5
introduces a single 'rename' function which seems a relatively small
delta with respect to [24]. The authors point us back to section 3
(mixed evaluation order) for further contributions with respect to
[24] to handle EPFLTL, but it is then not clear why Section 3 is
separate from Section 5.

The paper should better position its contributions wrt. related work.
Throughout the paper, the authors should make it more obvious to the
reader that only logics prefixed with an E are new logics introduced
in this work (if I understood the paper correctly). However, the
authors present a much clearer and unified semantics for E/Q/P/FLTL
than can be found in prior work - this is a valuable contribution in
and of itself. Highlighting this may strengthen the motivation for
the extensive re-presentation of existing work.

Additionally, the use of predicates to encode information about the
prefix of the state (system inputs seen so far), and thereby allowing
arbitrary data over infinite domains, was explored in 'Synthesizing
Functional Reactive Programs' by Finkbeiner et. al
https://arxiv.org/abs/1712.00246.

Finally, the paper contains typos that create problematic ambiguities.
As an example, the top of page 5 notes that the logic PQLTL is
obtained by restricting QPLTL to past modalities. From context, it
appears this should read as QLTL, not QPLTL. Furthermore, by page 6
the authors are proving properties of QPLTL, but PQLTL is no longer
referenced. Although from context the reader can infer that QPLTL and
PQLTL these should be taken as the same logic (except on page 5 when
QPLTL refers to QLTL), these inferences should not be left to the
reader. I also believe that there is an issue with Theorem 2 - when
comparing the expressive power of EPFLTL and QFPLTL, the statement
instead reads as comparing EPFLTL and QFLTL.

----------------------- REVIEW 3 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: 2 (accept)

----------- Overall evaluation -----------
This paper considers various extensions of LTL, considering addition of auxiliary variables and quantification (static and dynamic).  It discusses how logics with quantification over variables is equivalent to adding "rules" involving auxiliary variables.  The formulation with rules is more natural in the context of runtime verification as the rules map more naturally to state machines, which are often used for expressing properties being monitored.  The logic is more expressive than first order LTL (e.g., it can express transitive closure).  The ideas have been implemented in a tool that supports checking formulae over infinite domains (e.g., integers), using an efficient encoding of values seen so far using BDDs.  The paper presents preliminary results on some toy examples.  Overall, I found this work to be interesting, and the relation between the logics and the motivation for the work explained well.  The idea of using rules seems clever, and maps naturally to the runtim!
 e verification algorithm.  The formalism is at times a bit sketchy, but the overall ideas are clearly explained.  The experimental results seem preliminary: apart from the fact that the examples are made up, it's unclear how the collection of traces was generated.  It would be more convincing to see this applied to more realistic examples (esp the transitive closure property surely has many applications).  However, the tool is apparently available publicly (links hidden due to blind review).

Comments:

* p.1, fifth line from bottom: "By Wolper" ==> "by Wolper"

* p.2, second para, "unexpressiveness" ==> "inexpressiveness"

* p.3, the Related Work section is quite terse.  In particular, it lists a set of papers, but does not really "relate" the current work.  (Actually, the introduction on p.2 does a better job of this.)

* p.5, formulae (1) and (2) could be made to look more similar.  In (2), you distribute H() over the /\.  Could do the same in (1) with \Box

* p.5, middle of page.  Your restriction on the rules is that
   "\phi_i is a PLTLT property where propositions from B can only occur within the scope of (-)"
  But at the bottom of the page you say
   "auxiliary variables appearing in the formulas \phi_i must occur within the scope of a (-)"
  These seem inconsistent (since the auxiliary variables are in A, not in B).

* p.6, Lemma 1, "Let \sigma be a model with states over the B".  Get rid of "the"

* p.8, 2nd para, "where one distinguished state, s, in a sink state".  Change "in" to "is"

* p.11, item 3 under "Extending FLTL with rules".  "An auxiliary relations r_j can appear"
    Change "relations" to "relation"

* p.12, second para, "The reason is that every prefix of an model".  Change "an" to "a"

* p.15, second para, "The properties are The ASCII version of the logic" ?? Fix.

* p.15, third para, "The third alternative here states that we in the previous state were in"
   Should be "The third alternative here states that in the previous state we were in"

------------------------------------------------------

Best wishes,
Isil Dillig & Serdar Tasiran
CAV 2019 co-chairs
