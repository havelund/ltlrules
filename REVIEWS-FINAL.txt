Dear  Klaus,

    We regret to inform you that your submission 139 was not accepted at CAV 2019.

    This year’s CAV was very competitive: From among the 258 submitted papers, we accepted 13 tool papers, 2 case study papers, and 52 regular papers, which amounts to an acceptance rate of roughly 26%.

    The reviews of your paper are attached to this email. We hope that you will find the feedback from the CAV’19 PC useful, and we hope to see you at the conference in New York City in July!

  Isil & Serdar


----------------------- REVIEW 1 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: 0 (borderline paper)

----------- Overall evaluation -----------
The paper describes several extensions to the temporal logic LTL, motivated by runtime verification application. The extensions are as follows:
- dynamic quantification - an LTL formula is augmented with \exists q, where q stands for an auxiliary variable that labels the states on the trace under verification;
- extension with rules - an LTL formula is augmented with a rule "where <some formula on auxiliary variables>"
- first-order LTL with dynamic quantification and with rules (separately).

The authors claim that these extensions are useful for runtime verification and present some minimal experimental results from running a BDD-based implementation of the extensions.

I am not quite on board with the motivation of the paper. In runtime verification, the truth values of formulas are determined on a single trace, hence, in particular, LTL and CTL are equivalent, and the verification is hence polynomial. It is also quite standard in model-checking to augment the intermediate states on the path with the truth values of subformulas (this is how CTL model checking is done, and hence also LTL for a single trace). Wouldn't it address at least some of the concerns of the authors (that is, which subformulas are satisfied in which states)?

Also, I see no reference to PSL, which is the IEEE standard for property specification languages, or to ForSpec, which is Intel's specification language. I am wondering whether these would already provide the necessary functionality.

Adding quantification is solvable, in general, with a QBF solver, and in some cases even without it. In the Intel's paper about enhanced vacuity from the beginning of 2000's, they studied the problem of model-checking a quantified formula and demonstrated that for the types of formulas they constructed it is no harder than model-checking.

Finally, I might be wrong, but it seems to me that BDDs are no longer widely used in model-checking, replaced by SAT and SMT solvers. I am wondering whether the implementation with BDDs is interesting enough.


----------------------- REVIEW 2 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: -1 (weak reject)

----------- Overall evaluation -----------
# Summary

In this paper the authors introduce an extension to LTL (which the
authors call ELTL) that allows reasoning about unbounded datatypes by
way of auxillary relations. These auxillary relations' values at a given
time stamp are defined by the prefix of the current state of the
reactive system. This allows the logic to specify properties of data
values over infinite domains. The authors implemented a system for
the runtime verification of properties expressed in this new logic. A
evaluation is provided that demonstrates how the tools performs on
benchmarks of various sizes.

# Review

While the paper explores a potentially useful abstraction for runtime
verification, it was hard to fully understand the motivation for this
work. Some ways that the work could be strengthened are listed below.

Thm. 1 and Lemma 2 show that the introduced logics (ELTL and EPLTL)
have the same expressive power as Q(P)LTL. The authors should make
the benefit of introducing these new logics more clear. Thm. 2 shows
that QPFLTL is more expressive than EPFLTL, but the authors do not
provide any complexity results on the decidability of these logics -
for what benefit are we trading the expressivity? Thm 2 also opens
the question of whether EQPFLTL makes sense and if so how it relates
to the other permutations of (E/Q/F/PLTL).

The limitations of existing runtime verification systems for data 
intensive systems could be made more clear through an evaluation 
that compares the use of EFPLTL for runtime verification with the 
alternative existing approaches. At the moment the evaluation only 
presents benchmarks for the introduced tool, but does not situate 
this evaluation in the context of existing runtime verification tools.

Furthermore, the evaluation includes a 'spawning' trace where analysis
time appears to scale exponentially in the size of the trace. The
authors mention this is possibly due to the increasingly large amount
of data that must be stored as the trace grows. As the system is
intended to be used for runtime verification, what practical
consideration must be made given the exponentially scaling with
respect to the lifecycle of the task being monitored?

In addition, a more thorough analysis of memory usage should be
included in the evaluation. No information is provided on the system
that ran these evaluation results. Do these benchmarks' memory usage
exceed the available RAM and trigger disk operations? As the temporal
relations of (P)FLTL require increasingly large hash tables to save
their evaluations, what impact will this have on memory limited
systems? This is especially relevant for the many use cases of
runtime verification on embedded systems.


Another issue is that it was hard to identify the paper's
contribution. The section on 'Runtime verification algorithm for
PFLTL' has already been described in [24]. To handle EPFLTL, Sec 5
introduces a single 'rename' function which seems a relatively small
delta with respect to [24]. The authors point us back to section 3
(mixed evaluation order) for further contributions with respect to
[24] to handle EPFLTL, but it is then not clear why Section 3 is
separate from Section 5.

The paper should better position its contributions wrt. related work.
Throughout the paper, the authors should make it more obvious to the
reader that only logics prefixed with an E are new logics introduced
in this work (if I understood the paper correctly). However, the
authors present a much clearer and unified semantics for E/Q/P/FLTL
than can be found in prior work - this is a valuable contribution in
and of itself. Highlighting this may strengthen the motivation for
the extensive re-presentation of existing work.

Additionally, the use of predicates to encode information about the
prefix of the state (system inputs seen so far), and thereby allowing
arbitrary data over infinite domains, was explored in 'Synthesizing
Functional Reactive Programs' by Finkbeiner et. al
https://arxiv.org/abs/1712.00246.

Finally, the paper contains typos that create problematic ambiguities.
As an example, the top of page 5 notes that the logic PQLTL is
obtained by restricting QPLTL to past modalities. From context, it
appears this should read as QLTL, not QPLTL. Furthermore, by page 6
the authors are proving properties of QPLTL, but PQLTL is no longer
referenced. Although from context the reader can infer that QPLTL and
PQLTL these should be taken as the same logic (except on page 5 when
QPLTL refers to QLTL), these inferences should not be left to the
reader. I also believe that there is an issue with Theorem 2 - when
comparing the expressive power of EPFLTL and QFPLTL, the statement
instead reads as comparing EPFLTL and QFLTL.


----------------------- REVIEW 3 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: 2 (accept)

----------- Overall evaluation -----------
This paper considers various extensions of LTL, considering addition of auxiliary variables and quantification (static and dynamic).  It discusses how logics with quantification over variables is equivalent to adding "rules" involving auxiliary variables.  The formulation with rules is more natural in the context of runtime verification as the rules map more naturally to state machines, which are often used for expressing properties being monitored.  The logic is more expressive than first order LTL (e.g., it can express transitive closure).  The ideas have been implemented in a tool that supports checking formulae over infinite domains (e.g., integers), using an efficient encoding of values seen so far using BDDs.  The paper presents preliminary results on some toy examples.  Overall, I found this work to be interesting, and the relation between the logics and the motivation for the work explained well.  The idea of using rules seems clever, and maps naturally to the runtim!
 e verification algorithm.  The formalism is at times a bit sketchy, but the overall ideas are clearly explained.  The experimental results seem preliminary: apart from the fact that the examples are made up, it's unclear how the collection of traces was generated.  It would be more convincing to see this applied to more realistic examples (esp the transitive closure property surely has many applications).  However, the tool is apparently available publicly (links hidden due to blind review).

Comments:

* p.1, fifth line from bottom: "By Wolper" ==> "by Wolper"

* p.2, second para, "unexpressiveness" ==> "inexpressiveness"

* p.3, the Related Work section is quite terse.  In particular, it lists a set of papers, but does not really "relate" the current work.  (Actually, the introduction on p.2 does a better job of this.)

* p.5, formulae (1) and (2) could be made to look more similar.  In (2), you distribute H() over the /\.  Could do the same in (1) with \Box

* p.5, middle of page.  Your restriction on the rules is that
   "\phi_i is a PLTLT property where propositions from B can only occur within the scope of (-)"
  But at the bottom of the page you say
   "auxiliary variables appearing in the formulas \phi_i must occur within the scope of a (-)"
  These seem inconsistent (since the auxiliary variables are in A, not in B).

* p.6, Lemma 1, "Let \sigma be a model with states over the B".  Get rid of "the"

* p.8, 2nd para, "where one distinguished state, s, in a sink state".  Change "in" to "is"

* p.11, item 3 under "Extending FLTL with rules".  "An auxiliary relations r_j can appear"
    Change "relations" to "relation"

* p.12, second para, "The reason is that every prefix of an model".  Change "an" to "a"

* p.15, second para, "The properties are The ASCII version of the logic" ?? Fix.

* p.15, third para, "The third alternative here states that we in the previous state were in"
   Should be "The third alternative here states that in the previous state we were in"


----------------------- REVIEW 4 ---------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification
AUTHORS: Klaus Havelund and Doron Peled

Overall evaluation: 0 (borderline paper)

----------- Overall evaluation -----------
This paper describes a method of adding auxiliary state machines to
first-order linear temporal logic specifications and a method of
monitoring these specifications that extends an earlier approach for
first-order LTL. As is common in run-time monitoring, past-time temporal
logic is used.

Adding auxiliary state machines to temporal specifications is, of
course, not new. It was used, for example, in early model checking
tools like SMV and RuleBase. There are some nice aspects to the
particular approach proposed here, however. First, the auxiliary state
is expressed in terms of relations. This gives a succinct and abstract
way of expressing, for example, the state of protocols, and is similar
to the way the state is expressed in Gurevich's Evolving Algebras
(later Abstract State Machines) which were used in the 90's as a test
oracle for monitoring protocols (and later Ivy also used a similar
approach).  As an example in the paper shows, this gives a simple way
to construct the transitive closure of of a graph as it is built, even
though transitive closure is not expressible in the logic.  The
paper's approach goes a little further that this, however, since it
also allows the use of past-time temporal operators in the description
of the state machines. This doesn't add expressiveness for safety
properties, but it might improve succinctness or clarity of
specifications. It would be nice, in fact, if the paper showed an
example of this capability.

Adding the auxiliary state machines is a fairly straightforward
extension to the tool's existing monitoring algorithm based on BDD's.

Where the paper is somewhat lacking is in the evaluation. That is, a
few examples are given of specifications using auxiliary relations,
but these are toys and don't really indicate how well the method will
scale. The free use of quantifiers in the formulas, while it allows
succinct expression, might also harm scalability. As an example, to
avoid the costly use of quantifiers, it is typical and very helpful to
use maps (i.e., functions) in the auxiliary state. A map can be
modeled by a relation but at the cost of existential quantifier when
the map is applied. Because of such trade-offs, it would be very
useful to have a substantial protocol expressed in the logic, and to
see how well the monitoring algorithm scales, compared, for example,
to the Abstract State Machines approach. The transitive closure
example hints at what is possible in the formalism, but it doesn't
tell us if the approach makes a good (or transparent) trade-off
between ease of expression and cost.

The paper's formalism gives an elegant way of capturing the common
notion of auxiliary variables. However, it doesn't go deeply enough into the questions of succinctness and tractability that are crucial to any specification formalism, and as a result it doesn't really motivate the approach. There is a fair amount of material in the paper that is familiar or is background from prior work. Perhaps this could be reduced in order to make space for discussion of these issues.


-------------------------  METAREVIEW  ------------------------
PAPER: 139
TITLE: An Extension of LTL with Rules and its Application to Runtime Verification

Although the reviewers found the paper's formalism to be elegant and clearly explained, there were concerns in the areas of motivation, technical depth and practical evaluation. Reviewers would like to see a number of specific issues addressed including comparison to the wide range of existing specification techniques, the question of memory behavior over long traces and more substantial examples in the evaluation. In addition, a deeper analysis of how the logic's design choices affect succinctness, readability and tractability would be helpful.
