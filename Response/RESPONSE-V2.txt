
Contribution: in previous work [23,24] we presented a BDD-based
monitoring algorithm for PFLTL: Past-time First-order LTL. This logic
has limitations in expressiveness exemplified on page 10. As main
contribution, we consequently present an extension of this logic (page
11):

  EPFLTL: Extended Past-time First-ordrer LTL

The extension adds rules to temporal properties. Example properties
(not expressible in PFLTL) are shown (Figure 2). 

We build this result in steps, making the argument initially for
propositional LTL (Sections 2,3) and then for first-order LTL
(Sections 4,5). 

For each case (propositional and first-order) we present three
logic-classes.  Let X stand for LTL/PLTL (propositional case) or
FLTL/PFLTL (first-order case):

  core form       :  X
  quantified form : QX (extends expressiveness but no monitoring algorithm known)
  extended form   : EX (extends expressiveness with shown monitoring algorithm)
  
----------[REVIEW-1]----------

> and present some _minimal_ experimental results

We have presented many experiments in previous papers, which are
publicly available with our tool. We here added experiments to show
the strength of the extension.

> verification is hence polynomial ...

For unbounded data and unbounded sequences, the size of information
that needs to be stored can grow unboundedly. Our BDD representation,
however, shows impressive results, handling large traces.

> Also, I see no reference to PSL, ... ForSpec, ...

We will cite this work. However, PSL is limited in the way it handles
data, and is basically a strong propositional logic. It is equivalent
to some propositional logics we cite.  We introduced the propositional
extension with rules to demonstrate how simple (not more expressive!)
our extension is, that a simple extension to a classical RV algorithm
handles it, and to motivate the related extension for first-order LTL.

> In the Intel's paper about enhanced
> vacuity from the beginning of 2000's, they studied the problem of
> model-checking a quantified formula

There are two types of quantifiers: propositional quantifiers, as
QLTL, as dealt with in the paper you mention, and first-order
quantification (in our logics named with letter 'F'). Our contribution
is w.r.t. handling the first-order version, so the work mentioned is
not connected.

> ... BDDs are no longer widely used in model-checking, replaced by SAT and SMT ..

The main problem studied in handling RV for first-order LTL with data
is the representation of relations over data, which are accumulated
throughout the execution. In our BDD encoding of relations, we can use
efficient Boolean BDD operators to implement intersection, union and
complementation of relations. This is surprisingly efficient allowing
handling of very large traces with lots of data.


----------[REVIEW-2]----------


> have the same expressive power as Q(P)LTL. The authors should make the
> benefit of introducing these new logics more clear.
> Thm. 2 shows that
> QPFLTL is more expressive than EPFLTL...for what benefit are we trading the expressivity?

The main reason for moving from 'Q' to 'E', e.g. from QPFLTL to
EPFLTL, is that we can show how to construct an efficient monitoring
algorithm for 'E' (e.g. EPFLTL), whereas we do not see how to do this
for 'Q' (e.g. QPFLTL). We do not believe there is a reasonable
algorithm for the 'Q' version and the example in the proof gives some
insight of what is involved.

> the evaluation only presents benchmarks for the introduced tool

In [23] we compared with MonPoly, which is closest, since it includes
FPLTL.

> time appears to scale exponentially in the size of the trace. 

The BDD representation of relations showed on many examples (open
source) to be quite compact. The original version of the tool also
performs a clever form of garbage collection, described in [24].
Indeed, BDDs are not a magic fix-all tool, but we obtain impressive
results.

> a more thorough analysis of memory usage should be included

Memory analysis is missing, agreed.

> The paper should better position its contributions wrt. related work.

Yes, although see also introduction to this response above.

> Additionally, the use of predicates ... was explored in 'Synthesizing Functional Reactive Programs'.

We were not aware of this paper (it appears as an archived paper).  It
seems that the TSL assignments only assign one value to a
variable. Our approach maintains sets of such values, needed for
monitoring. But we do not claim to have introduced predicates to
encode information about the prefix of the state, we refer to paper
[4].

----------------------- REVIEW 3 ---------------------

> unclear how the collection of traces was generated.

The artificial traces were generated by a trace generating program
parameterized with various constants, indicating how many events of
various kinds should be generated, and the patterns with which they
are generated. The objective was to generate as many data values in
the trace as possible, while at the same time also cause repetition of
patterns.

> more convincing to see this applied to more realistic examples

Agreed! 

