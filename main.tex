\documentclass{llncs}
%\documentclass[converence,10pt]{IEEEtran}
%\IEEEoverridecommandlockouts
%\usepackage{cite}
%\usepackage{amsmath,amssymb,amsfonts}
%\usepackage{algorithmic}
%\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{bm}
%\usepackage{xcolor}
%\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\Exists}{\bm{\exists}\kern-0.6em\bm{\exists}}
\newcommand{\Forall}{\bm{\forall}\kern-0.6em\bm{\forall}}

\input{macros}

\begin{document}

\title{An Extension of LTL with Rules\\ 
and its Application to Runtime Verification}

\ignore{\author{
\begin{tabular}{ccc}
Klaus Havelund & \vspace{0.2cm} & 
Doron Peled \\
NASA Jet Propulsion Laboratory, Pasadena, USA & & 
Bar Ilan University, Ramat Gan, Israel \\
klaus.havelund@jpl.nasa.gov & & doron.peled@gmail.com
\end{tabular}
}
}

\ignore{
\author{\IEEEauthorblockN{Klaus Havelund} 
\IEEEauthorblockA{\textit{Laboratory for Reliable 
Software} \\
\textit{NASA Jet Propulsion Laboratory}\\
Pasadena, USA \\
klaus.havelund@jpl.nasa.gov}\\\mbox{}\\
\and
\IEEEauthorblockN{Doron Peled} 
\IEEEauthorblockA{\textit{Dep. of Computer Science} \\
\textit{Bar Ilan University}\\
Ramat Gan, Israel \\
doron.peled@gmail.com}
}
}

%\thanks{Copyright 2018. All rights reserved.}

\author{ 
Klaus Havelund~\thanks{The research performed by this author was carried out at Jet Propulsion Laboratory, California Institute of Technology, under a contract with the National Aeronautics and Space Administration.} 
\and
Doron Peled~\thanks{The research performed by this author was partially funded by Israeli Science Foundation grant 1464/18: 
``Efficient Runtime Verification for Systems with Lots of Data and its Applications''.
}
}




\institute{
Jet Propulsion Laboratory, \\
California Institute of Technology, USA 
\and
Department of Computer Science \\
Bar Ilan University, Israel
}




%\hfill
\maketitle

\begin{abstract}

Runtime Verification (RV) consists of analyzing execution 
traces using formal techniques. 
%RV is scalable and 
%therefore has a big potential for infusion in software 
%engineering practices. 
It includes monitoring the 
execution of a system against properties formulated in 
Linear Temporal Logic (LTL). 
LTL offers a succinct notation for writing useful 
specification properties. However, it is limited in 
expressiveness in the propositional case, and several 
theoretic (non-operational) extensions have therefore been proposed. Furthermore, for many practical cases, there is a need to monitor properties 
that carry data, where one can use formalisms like 
first-order LTL. We show that 
first-order LTL has similar expressive
limitations as the propositional version. We suggest here 
two related extensions for increasing the expressive power: 
one for propositional LTL and one for 
first-order LTL. These extensions have a simple incremental operational 
semantics that is more suitable for RV than previously 
suggested extensions. We show that the 
propositional extension has the same expressiveness as the 
classical extensions, and demonstrate its
adoption for runtime verification of first-order safety 
properties. Finally, we expand the BDD-based runtime verification 
tool \dejavu{}  to support our extension and perform some 
experiments.

\end{abstract}

\input{rule-ltl}

\input{implementation}

\input{conclusion}

\input{prop.bib}

\newpage
\appendix

\section{Appendix}

\klaus{In the text below mention what $i$ is (time point, position, ...}

\subsubsection{Sketch of proof of Theorem~\ref{theo2}.}
As we defined the semantics of
EFLTL by translating into QFLTL, QFLTL is at least as
expressive as EFLTL. We show here that 
the expressive power of EFLTL is strictly smaller than that of
QFLTL through the following example. It consists of
a temporal relation\footnote{We abuse notation and
use the same name for the relation and for its
denotation in the logic. Also, $r [ i ]$ has zero
parameters; as noted before, this is a natural extension to the syntax and semantics presented above.} $r$ with only one parameter, so $r [ i ]$
has a Boolean value. We will henceforth say that $r$ occurs
in state $i$. Another relation is $v$, with
two parameters. For each $i$, if $r$ does not appear in the
state, 
then there is a value $a$ from some (infinite) domain,
such that $v ( a, i )$, 
i.e., $v(a)$ appears in $i$.
The property requires that there are no two sets of values appearing within the relation $v$ (as $v(a)$) between successive occurrences of $r$ that are the same.

\klaus{Below: isn't it the other way around, the first is not a model and the second is a model?}

Hence, the sequence of states 
\[ \{ r \} \{ v(1) \}  \{ v(2) \} \{ v(3) \}  \{ r\}  \{ v(2) \}  \{  v(1) \}  \{  v(3) \} \{  r \} \] is a model of this formula, while \[ \{ r \} \{ v(1) \}  \{ v(2) \}  \{ v(2) \}  \{ r\}  \{ v(2) \}  \{  v(1) \}  \{  v(5) \}  \{  r \}\] is not.
The QFLTL formula is a bit involved, hence given in several parts (macros).

\begin{itemize}
\item $add(P) ::= \forall x \, (P(x) \leftrightarrow (v(x) \vee \ominus P(x))$ [The set $P$ differs in the current state from the previous one only by values $a$ that appear in $v(a)$.]
\item $same(P) ::= \forall x \, (P(x) \leftrightarrow \ominus P(x))$ 
[The set of elements $x$ for which
$P (x)$ holds
contains the same elements as in the previous state.]
\item $empty (P) ::= \forall x \neg P(x)$ [The set $P$ is empty.]
\item $equal (P,Q) ::= \forall x (P(x) \leftrightarrow Q(x))$ 
[The sets represented by the relations
$P$ and $Q$ contain the same elements {\em in the current state}.]
\item $collect(P, \varphi, \psi) ::=
       r \wedge same(P) \wedge \varphi \wedge 
       \ominus ((add(P)\wedge \neg r \wedge \varphi) \ \since \ (r \wedge empty(P) \wedge \psi))$  [Collect elements $a$ in $v(a)$, while $\varphi$ holds, 
       since the previous state where $r$ 
       and $\psi$ held.]
\item $init ::= r \wedge \Box (r \leftrightarrow \neg \exists x \, v(x))$ [$r$ holds in the first state, and $v(a)$ with some value $a$ holds in states where $r$ does not hold.]
\item $init \wedge \neg \Exists A \Exists B (equal (A, B) \wedge \\
collect(B, same(A),\, same(A)) \ \since \ collect(A, true, true))$
[There are no two sequences of states where $v(a)$ holds
with various values $a$, between a pair of states satisfying $r$ that contain exactly the same elements (regardless of repetition).]
\end{itemize}

\klaus{Above: maybe need to point out what the top formula is.}

\klaus{Above: isn't there missing a $\Box$ in the main formula?}

We prove that the above property cannot be expressed in EFLTL.
We use a combinatorial argument.
In EFLTL, after every prefix of the input, it is
sufficient to keep a finite set of (non temporal) relations over the
data elements seen in the input, which
summarizes the prefix. This follows from the set
semantics, which appears in Section~\ref{EPLTLRV}, 
where the interpretation of
each subformula, and the auxiliary relations,
at a particular state is a relation, and the interpretation 
of a property a prefix of length $i$ only depends on
these relations. Now, the number of such possible relations
for a fixed number of data elements $N$ is polynomial
in $N$. However, the above property checks whether
a set of values that appear within the relation $v$, between two consecutive appearances
of $r$'s, are the same. For that, one needs to keep a set of
subsets of the elements that appeared in the input so far. 
But the number of such subsets is exponential in $N$. \qed

\klaus{Above: why set of subsets?}

\iffalse
{\bf Comments.} First, note that the reason that QFLTL {\em can} express the property in Theorem~\ref{theo2}, is that it allows to augment the input relations with auxiliary relations that are not fixed. That is, for an auxiliary relation $R$,
$R [ i ]$ is not fixed, and can change per different
prefixes (of length at least $i$), or even in different
subformulas. Second, given a simple extension to EFLTL, where 
one can use a variable that represents an updatable
counter (or a generator of distinct values), one can express the property used in~\ref{theo2}, by
keeping a relation where values between different occurrences of the event $r$ are paired with distinct values, hence, representing an unbounded set of sets.
\fi

%%%M
\subsection*{Details of left to right direction of Theorem~\ref{theo1}.}
One can translate any QLTL property into a second order monadic logic in a standard
way~\cite{Thomas}, and then from
second order monadic logic to a deterministic Muller automaton $M = (S, \iota , \Sigma, \Delta, {\cal F})$ (a B\"{u}chi automaton may not always be deterministic), where $S$ is the set of states, $\iota \in S$ is the initial state, $\Sigma$ is the set of inputs, each $\alpha \in \Sigma$ is a minterm (i.e., conjunction of
each variable in the set negated or non-negated) of the variables in $B$, $\Delta : S \times \Sigma \mapsto S$ is the transition function, and ${\cal F} = \{ F_1 , \ldots , F_k \}$ is the accepting set. A muller automaton 
accepts a run if it 
passes infinitely often in exactly
one of the specified accepting sets. To formulate an equivalent ELTL formula,
the auxiliary variables represent the states $S$ of $M$, i.e., $a_s$ represents the state $s \in S$.

%\klaus{The following formulation above is not not clear: ``where an accepted input needs to pass infinitely often in exactly
%one of the specified sets''.}

\noindent
Then we translate $M$ into an ELTL formula
of the form: 

\begin{tabbing}
\ \ \ \ \ $\bigvee_{F \in {\cal F}} \bigwedge_{s \in F} ( \Box\Diamond a_s \wedge \bigwedge_{s \not\in F} \Diamond \Box \neg a_s)$
where \\
\ \ \ \ \ \ \ \ \ \ $a_s :=   ( \alpha_{\iota} \wedge \ominus \false ) \vee \bigvee_{\Delta ( s'
, \alpha ) = s } 
(\alpha \wedge \ominus a_{s'}) 
\, :\,  s \in S$
\end{tabbing}

%\klaus{Above: should $s=i \rightarrow \neg \ominus \true$ instead be (note: two changes):
%$\neg \ominus \true \rightarrow a_s=i$
%}
%\klaus{Above: can't judge whether the $\bigwedge_{s \not\in F} \Diamond \Box %\neg a_s)$ is correct.}
\noindent
Basically, the assignments to the auxiliary variables are used to simulate the change of states\footnote{It is possible to use only $\lceil \log ( | S | ) \rceil$
variables, at the expense of longer and more complicated formulas.}, and the main formula expresses the Muller acceptance condition. \qed

\end{document}


