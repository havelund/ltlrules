
\section{Introduction}

Runtime verification (RV)  \cite{bartocci18,havelund-rv-data-2018} 
refers to the use of rigorous (formal) 
techniques for {\em processing} execution traces emitted by a system being observed. 
The purpose is typically to evaluate the behavior of the observed system. We focus here on {\em specification-based} runtime verification, 
where an execution trace is checked against a property expressed in a formal logic, 
in our case variants of Linear Temporal Logic (LTL).

LTL is a common specification formalism for reactive and concurrent systems. It is often used in model checking and runtime verification. Another formalism that is used for the same purpose is finite automata, often over infinite words. This includes B\"{u}chi, Rabin, Street, Muller and Parity automata~\cite{Thomas}, all having the same expressive power. In fact, model checking of an LTL specification
is usually performed by first translating the specification into a B\"{u}chi automaton. The automata formalisms are more expressive than LTL, with a classical example by Wolper~\cite{Wolper}, showing that
it is not possible to express in LTL that every even state in
the sequence satisfies some proposition $p$. 
%
This has motivated extending LTL in various ways to achieve the same expressive power as B\"{u}chi automata:
Wolper's ETL \cite{Wolper,WVS} uses right-linear grammars,
%\footnote{ETL allows a formula $\varphi$ to be
%the definition of a right-linear grammar
%(equivalent to a finite automaton) together with a mapping $M$ from the terminals 
%of the grammar to temporal sub-formulas. A trace satisfies $\varphi$ if there is some word $w$ of terminals 
%generated by the grammar, such that the trace in every position $i$ satisfies the sub-formula $M(w_i)$, where 
%$w_i$ is the terminal at position $i$.}.
Sistla's~\QLTL{} extends LTL  
with dynamic (i.e., state-dependent, second-order) {\em quantification over propositions}~\cite{sistla-phd-83} and the PSL standard~\cite{psl-standard-2010} extends LTL with regular expressions.
However, these and other extensions have not been extensively used
for RV (e.g., \QLTL\  can be nonelementary more compact, hence
correspondingly more complex to monitor than LTL).

We therefore first present an alternative 
extension of  propositional LTL with {\em rules},
named \ELTL{}. These rules define and use
auxiliary propositions, not appearing in the execution itself. These propositions obtain their values in a state as a 
function of the prefix of the execution
up to and including that state, expressed as 
a past-time temporal formula. This extension fits
easily and naturally to existing RV algorithms that
use incremental
summaries of prefixes, e.g., the classical algorithm~\cite{HR}
for past time LTL (denoted here~\PLTL{}), maintaining also its linear time complexity (in the length of
the trace and the size of the formula).
In fact, our extension of the logic is inspired by that RV algorithm.
The logic~\ELTL{}
is shown to be equivalent to \QLTL{}
and its restriction to past properties is equivalent to 
B\"{u}chi automata and regular expressions.

Another expressiveness dimension is runtime verification of events that carry 
data, for which a first-order LTL supporting {\em quantification over data}
is appropriate, here referred to as \FLTL.
We demonstrate the weakness of \FLTL{} in
expressing Wolper's example, relativized to the first-order 
case,  and in expressing
the transitive closure of temporal relations over events. 
We therefore introduce two alternative ways 
of extending the expressive power of \FLTL{}, corresponding, respectively, to the propositional logics \QLTL{} and \ELTL{}. 
The first adds 
  quantification over relations of data, obtaining a logic 
referred to as \QFLTL{}.
The second extension adds rules for the first-order case, and is referred to as \EFLTL. Both of these extended logics can express the above examples.

%Adding rules to LTL furthermore interestingly allows to express the 
%transitive closure of a relation. That is, in first-order logic, given a relation 
%representing neighbors in a graph, it is not possible to express that there is a path between nodes. The  addition of rules allow this to be expressed.
We show that for the first-order case, in contrast to the propositional case, the extension of the logic with  quantification is more expressive than the extension with
rules.
\iffalse
While
it is not clear how to construct a monitoring
algorithm for \QFLTL{}, for which we 
can construct a monitoring
algorithm. 
\fi

Runtime verification is commonly restricted to
the {\em past-time} versions of LTL, i.e.,
to {\em safety} properties~\cite{AS}, where
a violation can be detected and demonstrated
after a finite prefix of the execution.
We refer to the logic
\PLTL{} for the propositional case and to \PFLTL{} for the first-order case; 
these logics also enjoy elegant RV algorithms, based on the ability to compute summaries of the observed
prefixes~\cite{HR,HPU}, as opposed to future
temporal logics~\cite{KV}.  The RV algorithm, presented here
for~\EPFLTL{} (the safety part of~\EFLTL{})
naturally
extends the RV algorithm for \PFLTL{} in~\cite{HPU} 
in the same way that the algorithm we present for \EPLTL{}
(the safety part of~\ELTL{}) extends the RV algorithm
in~\cite{HR} for \PLTL{}.

\iffalse
A past-time property has the quality
that given a finite prefix of the execution, it is known whether the property
is violated or not; this in contrast to future time properties.
Consistent with that, we provide runtime verification algorithms for the past-time versions of the rule-based extensions of propositional and first-order LTL. 
\fi
%
We further present a corresponding extension of the 
\dejavu{} tool
%\footnote{\dejavu{} is available at 
%\url{https://github.com/havelund/dejavu}.}
\cite{HPU,HPU-FMSD,HP}, that realizes the extension 
of first-order past-time LTL with rules (\EPFLTL). The \dejavu{} tool allows runtime 
verification on past-time first-order temporal logic over infinite domains (e.g., the 
integers, strings, etc.). It achieves efficiency by using a unique BDD representation of the data part; BDDs correspond to relations over a Boolean enumeration of the
input data (with a hash table representing the
correspondence between the data and the enumerations). This is a very different
use of BDDs from the classical model checking representation of sets of Boolean states\footnote{E.g., in~\cite{Green-berg},
BDDs are used to represent sets of program locations,
and the data
elements are represented
symbolically as a formulas.}.
A garbage collection algorithm tailored for that representation
also assists in obtaining efficiency.

Our main contribution is the LTL logics extended with rules (extensions prefixed with `R'), and in particular the
logic \EPFLTL{} (past-time first-order LTL extended with rules) and its implementation.
 The structure of the paper reflects our 
step-wise approach by 
first exploring the problem in the propositional case to form a basic understanding (but we believe that
our extension of propositional LTL is
interesting by itself), and then by addressing the more interesting first-order case. 

Numerous monitoring related expressive logics and systems have been developed over 
the past decades.
In the database community, relations have been added to temporal 
databases for aggregation \cite{Libkin}, calculating functions (sums etc.). 
Aggregations were also used in the runtime verification tool {\sc MonPoly}
\cite{agrebasin}.   
Numerous other systems have been produced for monitoring execution traces with data 
against formal specifications. 
These include e.g. {\sc Mop} \cite{Meredith2011}, {\sc Qea} \cite{Reger2015}, and {\sc Larva} \cite{larva}, which
provide automaton-based data parameterized logics; {\sc Lola}
\cite{LOLA}, which is based on stream processing; {\sc BeepBeep} 
\cite{halle-beepbeep-ieee-12} which is temporal logic-based; and the 
rule-based {\sc LogFire} \cite{havelund-logfire-sttt14}. These systems address the
expressiveness issues discussed in this paper in different ways. Our approach differs
from earlier such work by taking a starting point in LTL and
extending it with rules, implemented using BDDs.
%{\sc PSL} \cite{psl-standard-2010} is designed for model 
%checking and monitoring of hardware systems. By
%combining linear temporal logic and regular expressions 
%t achieves part of the goals of the here presented work. 
%However, it is finitely limited in the quantification it 
%allows over data.


%The contributions of this paper are both theoretical and practical. On the theory 
%side, we present and study extensions for propositional and first order linear-
%temporal logics and show the relations between them and existing versions. 
%On the practical side, we present RV algorithms for the extended logic, and 
%show how to cast them specifically in an efficient BDD-based implementation. We 
%present some experiments performed with our implementation and report on the 
%results. 


\iffalse
That is,
in Section~2 we first define the syntax and semantics of propositional LTL. We then review some of its classical extensions,
including \QLTL, and present our own extension \ELTL. In Section~3 we present a runtime verification algorithm for the extended past-time propositional LTL (\EPLTL). In Section~4 we review first-order linear temporal logic (\FLTL), present our extension \EFLTL, and study the relationships between the presented versions of first-order LTL. In Section~5 we present a runtime verification algorithm for the past-time version of the extended first-order LTL (\EPFLTL). Section~6 describes the implementation and provides experimental results. Finally, Section~7 concludes the paper. 
\fi
% ---

% Explanation of letters

\noindent {\bf Conventions.} As already outlined above,  we present several versions of LTL. 
We name the different versions by prefixing LTL with the following letters.
`P' : restricted to {\em P}ast-time temporal operators;
`F' : allowing {\em F}irst-order (static) quantification over data assigned to variables;
`Q' : adding second-order (dynamic) {\em Q}uantification over propositions/predicates; and finally
`R' : adding {\em R}ules, our main contribution.

% ---

% ----------------

%\iffalse
%The contributions of the papers are both theoretical, and
%practical. We study the extensions of propositional temporal logic (both full 
%version and past/safety version) and suggest a restricted (and, to our opinion, an 
%intuitive) extension that is equivalent to the power of quantified LTL or B\"{u}chi/
%finite automata. We then study 
%The corresponding extension to first-order LTL, replacing propositions with 
%relations, and allowing variables and constant values. We propose, for the first-
%order version, an extension similar to the one we propose for the propositional 
%case. But then we show that for the first-order case, this extension has
%less expressive power than adding quantification in the style of propositional 
%temporal logic.
%
%The extensions we suggest are in particular easy to implement, as an extension to 
%existing propositional/first-order runtime verification. We extend our tool \dejavu, 
%experiment with new examples that take advantage of the extension.
%\fi

%\noindent {\bf Conventions.}
%\label{sec:prelim}
%In this paper, we treat and present several versions of the logic LTL. To simplify
%the presentation, we prefix LTL with letters as follows:

%\begin{itemize}
%\item{P} restricts to P{\em ast} temporal operators.
%\item{F} allows F{\em irst-order} quantification over
%data assigned to variables that is uniform for all states. This quantification is referred to as {\em static} quantification.
%\item{Q} adds (second-order) Q{\em uantification} that is state-dependent. This is referred to as {\em } quantification.
%\item{E} allows E{\em xtending} the 
%set of objects that occur in the input with
%new auxiliary predicates (for the propositional versions) or relations (for the first-order cases) using past temporal logic rules that define them.
%\end{itemize}
